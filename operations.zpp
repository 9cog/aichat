/**
 * AIChat Operations Formal Specification (Z++)
 * 
 * This file formalizes the core operations of the AIChat system, including
 * configuration operations, session management, message processing,
 * RAG operations, and function calling.
 */

// ============================================================================
// Configuration Operations
// ============================================================================

/**
 * Initialize application configuration
 * 
 * Pre-conditions:
 * - Configuration file exists or can be created with defaults
 * - At least one LLM client is configured
 * 
 * Post-conditions:
 * - Configuration is loaded and validated
 * - Default model is selected
 * - Working mode is determined
 */
InitConfig
  ApplicationState'
  configPath: String
  mode: WorkingMode
  infoFlag: ùîπ
where
  // Configuration loaded from file or defaults
  config'.workingMode = mode
  ‚àß config'.infoFlag = infoFlag
  
  // At least one client configured
  ‚àß #config'.clients > 0
  
  // Models loaded from clients
  ‚àß availableModels' = flatten [Model::from_config(c.name, c.models) 
                                | c ‚àà config'.clients]
  
  // Default model selected
  ‚àß (‚àÉ m : availableModels' ‚Ä¢ modelId(m) = config'.modelId ‚àß currentModel' = m)
  
  // Initial state
  ‚àß sessions' = ‚ü®‚ü©
  ‚àß activeSession'.isSome = false
  ‚àß abortSignal' = false
  ‚àß dryRunMode' = config'.dryRun

/**
 * Update configuration setting
 */
ŒîUpdateConfig
  ApplicationState
  ApplicationState'
  setting: String
  value: JsonValue
where
  // Configuration updated
  config' = updateConfigField(config, setting, value)
  
  // Validate new configuration
  ‚àß validateState(ApplicationState'‚ü®config', ...‚ü©) = Valid
  
  // Update dependent state
  ‚àß (setting = "model" ‚áí 
     ‚àÉ m : availableModels' ‚Ä¢ modelId(m) = value ‚àß currentModel' = m)
  
  // Other state unchanged
  ‚àß sessions' = sessions
  ‚àß activeSession' = activeSession

/**
 * Sync models from remote URL
 */
SyncModels
  ŒûApplicationState
  url: String
  output: seq ModelData
where
  // Fetch models from URL
  output = fetchModelsFromUrl(url)
  
  // No state change (models updated externally)
  ‚àß ApplicationState' = ApplicationState

// ============================================================================
// Model Operations
// ============================================================================

/**
 * Select model for current session
 */
ŒîSelectModel
  ApplicationState
  ApplicationState'
  modelId: String
where
  // Model must exist
  ‚àÉ m : availableModels ‚Ä¢ modelId(m) = modelId
  
  // Update current model
  ‚àß currentModel' = (the m : availableModels | modelId(m) = modelId)
  
  // Update active session model if present
  ‚àß (activeSession.isSome ‚áí 
     activeSession'.value.model = currentModel'
     ‚àß activeSession'.value.modelId = modelId)
  
  // Other state unchanged
  ‚àß config' = config
  ‚àß sessions' = sessions

/**
 * List available models
 */
ŒûListModels
  ApplicationState
  modelType: ModelType
  output: seq Model
where
  output = [m : availableModels | m.data.modelType = modelType]

// ============================================================================
// Session Operations
// ============================================================================

/**
 * Create new session
 * 
 * Pre-conditions:
 * - Session name is unique
 * - Working mode supports sessions (REPL)
 * 
 * Post-conditions:
 * - New session created and added to sessions
 * - Session becomes active session
 * - Session has current model and role
 */
ŒîCreateSession
  ApplicationState
  ApplicationState'
  name: String
where
  // Pre-conditions
  name.value ‚â† ‚ü®‚ü©
  ‚àß ¬¨(‚àÉ s : sessions ‚Ä¢ s.name = name)
  ‚àß workingMode = REPL
  
  // Create new session
  ‚àß let newSession = Session‚ü®
      name = name,
      modelId = modelId(currentModel),
      model = currentModel,
      saveSession = config.saveSession,
      compressThreshold = Some(config.compressThreshold),
      messages = ‚ü®‚ü©,
      compressedMessages = ‚ü®‚ü©,
      tokens = 0,
      dirty = false,
      ...
    ‚ü©
    in sessions' = sessions ++ ‚ü®newSession‚ü©
       ‚àß activeSession' = Some(newSession)
  
  // Apply current role if active
  ‚àß (activeRole.isSome ‚áí 
     activeSession'.value.roleName = Some(activeRole.value.name)
     ‚àß activeSession'.value.rolePrompt = activeRole.value.prompt)

/**
 * Load existing session
 */
ŒîLoadSession
  ApplicationState
  ApplicationState'
  name: String
  path: String
where
  // Pre-conditions
  path.value ‚â† ‚ü®‚ü©
  ‚àß fileExists(path)
  
  // Load session from file
  ‚àß ‚àÉ session : Session ‚Ä¢ 
      session = parseSessionFromFile(path)
      ‚àß session.name = name
      ‚àß sessions' = sessions ++ ‚ü®session‚ü©
      ‚àß activeSession' = Some(session)
  
  // Validate session model
  ‚àß ‚àÉ m : availableModels ‚Ä¢ modelId(m) = activeSession'.value.modelId

/**
 * Save session to file
 */
ŒîSaveSession
  ApplicationState
  ApplicationState'
where
  // Pre-conditions
  activeSession.isSome
  ‚àß activeSession.value.dirty
  
  // Save to file
  ‚àß let session = activeSession.value
        path = session.path.value
    in writeSessionToFile(path, session)
  
  // Mark as clean
  ‚àß activeSession'.value.dirty = false
  ‚àß sessions' = [s : sessions | s.name ‚â† activeSession.value.name] 
                ++ ‚ü®activeSession'.value‚ü©

/**
 * Switch to different session
 */
ŒîSwitchSession
  ApplicationState
  ApplicationState'
  name: String
where
  // Session must exist
  ‚àÉ s : sessions ‚Ä¢ s.name = name
  
  // Save current session if dirty
  ‚àß (activeSession.isSome ‚àß activeSession.value.dirty ‚áí 
     saveSessionBefore(activeSession.value))
  
  // Switch to new session
  ‚àß activeSession' = Some(the s : sessions | s.name = name)
  
  // Update current model to session's model
  ‚àß currentModel' = activeSession'.value.model

/**
 * Delete session
 */
ŒîDeleteSession
  ApplicationState
  ApplicationState'
  name: String
where
  // Session must exist
  ‚àÉ s : sessions ‚Ä¢ s.name = name
  
  // Cannot delete active session
  ‚àß (activeSession.isSome ‚áí activeSession.value.name ‚â† name)
  
  // Remove from sessions
  ‚àß sessions' = [s : sessions | s.name ‚â† name]
  
  // Delete file if it exists
  ‚àß let session = (the s : sessions | s.name = name)
    in session.path.isSome ‚áí deleteFile(session.path.value)

/**
 * Compress session messages
 * 
 * Compresses old messages when token threshold exceeded
 */
ŒîCompressSession
  ApplicationState
  ApplicationState'
where
  // Pre-conditions
  activeSession.isSome
  ‚àß activeSession.value.tokens > activeSession.value.compressThreshold.value
  ‚àß #activeSession.value.messages > 1
  
  // Generate summary of messages to compress
  ‚àß let session = activeSession.value
        messagesToCompress = take(#session.messages / 2, session.messages)
        summary = generateSummary(messagesToCompress)
        summaryMessage = Message‚ü®
          role = System,
          content = MessageContent‚ü®[Text(summary)]‚ü©,
          toolCalls = ‚ü®‚ü©,
          toolCallId = None
        ‚ü©
    in activeSession'.value.compressedMessages = 
         session.compressedMessages ++ ‚ü®summaryMessage‚ü©
       ‚àß activeSession'.value.messages = 
         drop(#session.messages / 2, session.messages)
       ‚àß activeSession'.value.tokens = 
         Œ£_{m ‚àà activeSession'.value.compressedMessages ++ 
             activeSession'.value.messages} estimateMessageTokens(m)

// ============================================================================
// Role Operations
// ============================================================================

/**
 * Set active role
 */
ŒîSetRole
  ApplicationState
  ApplicationState'
  roleName: String
where
  // Role must exist
  ‚àÉ r : roles ‚Ä¢ r.name = roleName
  
  // Set active role
  ‚àß activeRole' = Some(the r : roles | r.name = roleName)
  
  // Update session if active
  ‚àß (activeSession.isSome ‚áí 
     activeSession'.value.roleName = Some(roleName)
     ‚àß activeSession'.value.rolePrompt = activeRole'.value.prompt
     ‚àß activeSession'.value.dirty = true)
  
  // Update model if role specifies one
  ‚àß (activeRole'.value.modelId.isSome ‚áí 
     ‚àÉ m : availableModels ‚Ä¢ modelId(m) = activeRole'.value.modelId.value
     ‚àß currentModel' = m)

/**
 * Clear active role
 */
ŒîClearRole
  ApplicationState
  ApplicationState'
where
  activeRole' = None
  ‚àß (activeSession.isSome ‚áí 
     activeSession'.value.roleName = None
     ‚àß activeSession'.value.rolePrompt = ""
     ‚àß activeSession'.value.dirty = true)

/**
 * List available roles
 */
ŒûListRoles
  ApplicationState
  includeBuiltin: ùîπ
  output: seq String
where
  output = [r.name | r : roles]
         ++ (if includeBuiltin 
             then ‚ü®SHELL_ROLE, EXPLAIN_SHELL_ROLE, CODE_ROLE‚ü© 
             else ‚ü®‚ü©)

// ============================================================================
// Agent Operations
// ============================================================================

/**
 * Initialize and activate agent
 */
ŒîActivateAgent
  ApplicationState
  ApplicationState'
  agentName: String
  variables: String ‚á∏ String
where
  // Agent must exist
  ‚àÉ a : agents ‚Ä¢ a.name = agentName
  
  // Initialize agent variables
  ‚àß let agent = (the a : agents | a.name = agentName)
        initVars = Agent::init_agent_variables(
          agent.definition.variables, 
          variables, 
          config.infoFlag
        )
    in activeAgent' = Some(Agent‚ü®
         ...agent,
         sharedVariables = initVars
       ‚ü©)
  
  // Clear active session (agents use their own context)
  ‚àß activeSession' = None
  
  // Load agent's RAG if available
  ‚àß (activeAgent'.value.rag.isSome ‚áí 
     activeRag' = Some(activeAgent'.value.rag.value))

/**
 * Deactivate agent
 */
ŒîDeactivateAgent
  ApplicationState
  ApplicationState'
where
  activeAgent' = None
  ‚àß activeRag' = None

/**
 * Update agent variables
 */
ŒîUpdateAgentVariables
  ApplicationState
  ApplicationState'
  variables: String ‚á∏ String
  sessionScope: ùîπ
where
  // Agent must be active
  activeAgent.isSome
  
  // Update variables in appropriate scope
  ‚àß if sessionScope
    then activeAgent'.value.sessionVariables = Some(variables)
    else activeAgent'.value.sharedVariables = 
         activeAgent.value.sharedVariables ‚äï variables

// ============================================================================
// Message Processing Operations
// ============================================================================

/**
 * Process user input and send to LLM
 * 
 * This is the main operation for chat interaction
 */
ŒîProcessInput
  ApplicationState
  ApplicationState'
  input: Input
  output: String
  error: Option[String]
where
  // Pre-conditions
  inputIsValid(input)
  ‚àß (workingMode = REPL ‚áí activeSession.isSome)
  
  // Build message context
  ‚àß let userMessage = buildMessageFromInput(input)
        roleMessages = if activeRole.isSome 
                       then buildRoleContext(activeRole.value) 
                       else ‚ü®‚ü©
        sessionMessages = if activeSession.isSome 
                          then activeSession.value.compressedMessages 
                               ++ activeSession.value.messages
                          else ‚ü®‚ü©
        agentMessages = if activeAgent.isSome 
                        then buildAgentContext(activeAgent.value) 
                        else ‚ü®‚ü©
        ragContext = if activeRag.isSome ‚àß input.text.isSome
                     then retrieveRagContext(activeRag.value, input.text.value)
                     else None
        finalMessages = buildFinalMessages(
          roleMessages, 
          sessionMessages, 
          agentMessages, 
          userMessage, 
          ragContext
        )
    in processMessages(finalMessages, output, error)
  
  // Update session with new messages
  ‚àß (activeSession.isSome ‚àß error.isSome = false ‚áí 
     let userMsg = buildMessageFromInput(input)
         assistantMsg = Message‚ü®
           role = Assistant,
           content = MessageContent‚ü®[Text(output)]‚ü©,
           toolCalls = ‚ü®‚ü©,
           toolCallId = None
         ‚ü©
     in activeSession'.value.messages = 
        activeSession.value.messages ++ ‚ü®userMsg, assistantMsg‚ü©
        ‚àß activeSession'.value.dirty = true
        ‚àß activeSession'.value.tokens = 
          Œ£_{m ‚àà activeSession'.value.messages} estimateMessageTokens(m))
  
  // Check if compression needed
  ‚àß (activeSession'.isSome 
     ‚àß activeSession'.value.tokens > config.compressThreshold
     ‚áí activeSession'.value.compressing = true)

/**
 * Stream response from LLM
 */
ŒîStreamResponse
  ApplicationState
  ApplicationState'
  messages: seq Message
  chunks: seq String
where
  // Pre-condition: streaming enabled
  config.stream = true
  
  // Send request and collect chunks
  ‚àß chunks = streamChatCompletion(currentModel, messages)
  
  // Assemble full response
  ‚àß let fullResponse = concat(chunks)
    in ApplicationState' = updateWithResponse(ApplicationState, fullResponse)

/**
 * Execute function calls from LLM
 */
ŒîExecuteToolCalls
  ApplicationState
  ApplicationState'
  toolCalls: seq ToolCall
  results: seq ToolResult
where
  // Pre-conditions
  config.functionCalling = true
  ‚àß #toolCalls > 0
  
  // Execute each tool call
  ‚àß results = [ToolResult‚ü®call, executeTool(call)‚ü© | call : toolCalls]
  
  // All tool calls must have results
  ‚àß #results = #toolCalls
  
  // Results are valid JSON
  ‚àß (‚àÄ r : results ‚Ä¢ r.output ‚â† Null)

// ============================================================================
// RAG Operations
// ============================================================================

/**
 * Initialize RAG system with documents
 */
ŒîInitRag
  ApplicationState
  ApplicationState'
  name: String
  documentPaths: seq String
  ragPath: String
where
  // Pre-conditions
  name.value ‚â† ‚ü®‚ü©
  ‚àß #documentPaths > 0
  ‚àß ¬¨(‚àÉ r : rags ‚Ä¢ r.name = name)
  
  // Load documents
  ‚àß let documents = [loadDocument(path) | path : documentPaths]
        chunks = flatten [splitIntoChunks(doc, config.ragChunkSize, 
                                         config.ragChunkOverlap) 
                         | doc : documents]
        embeddings = generateEmbeddings(chunks, config.ragEmbeddingModel)
        ragData = Rag‚ü®
          name = name,
          documents = documents,
          embeddingModel = config.ragEmbeddingModel.value,
          rerankerModel = config.ragRerankerModel,
          topK = config.ragTopK,
          chunkSize = config.ragChunkSize.value,
          chunkOverlap = config.ragChunkOverlap.value,
          template = config.ragTemplate.value,
          path = ragPath
        ‚ü©
    in rags' = rags ++ ‚ü®ragData‚ü©
       ‚àß saveRagToFile(ragPath, ragData)

/**
 * Query RAG system
 */
ŒûQueryRag
  ApplicationState
  ragName: String
  query: String
  results: seq Chunk
where
  // RAG must exist
  ‚àÉ r : rags ‚Ä¢ r.name = ragName
  
  // Retrieve relevant chunks
  ‚àß let rag = (the r : rags | r.name = ragName)
        queryEmbedding = generateEmbedding(query, rag.embeddingModel)
        candidates = vectorSearch(rag, queryEmbedding, rag.topK * 3)
        reranked = if rag.rerankerModel.isSome
                   then rerank(candidates, query, rag.rerankerModel.value)
                   else candidates
    in results = take(rag.topK, reranked)

/**
 * Build RAG context for prompt
 */
buildRagContext : Rag √ó String ‚Üí String
buildRagContext(rag, query) = 
  let chunks = queryRag(rag, query)
      context = concat([c.text ++ "\n\n" | c : chunks])
      template = rag.template
  in replace(replace(template, "__CONTEXT__", context), 
             "__INPUT__", query)

// ============================================================================
// Function Calling Operations
// ============================================================================

/**
 * Register function declaration
 */
ŒîRegisterFunction
  ApplicationState
  ApplicationState'
  declaration: FunctionDeclaration
where
  // Function name must be unique
  ¬¨functions.contains(declaration.name)
  
  // Add to functions
  ‚àß functions'.declarations = functions.declarations ++ ‚ü®declaration‚ü©

/**
 * Execute function call
 */
ŒûExecuteFunction
  ApplicationState
  call: ToolCall
  result: JsonValue
where
  // Function must be registered
  ‚àÉ decl : functions.declarations ‚Ä¢ decl.name = call.name
  
  // Validate arguments against declaration
  ‚àß let declaration = (the d : functions.declarations | d.name = call.name)
    in validateArguments(declaration, call.arguments)
  
  // Execute function (implementation depends on function type)
  ‚àß result = invokeFunction(call)
  
  // Dry run mode returns mock result
  ‚àß (dryRunMode ‚áí result = json!{"status": "dry-run"})

// ============================================================================
// REPL Operations
// ============================================================================

/**
 * Execute REPL command
 */
ŒîExecuteReplCommand
  ReplState
  ReplState'
  command: String
  output: String
where
  workingMode = REPL
  
  // Parse command
  ‚àß let (cmd, args) = parseReplCommand(command)
    in (cmd = ".session" ‚áí handleSessionCommand(args, output))
       ‚à® (cmd = ".role" ‚áí handleRoleCommand(args, output))
       ‚à® (cmd = ".model" ‚áí handleModelCommand(args, output))
       ‚à® (cmd = ".file" ‚áí handleFileCommand(args, output))
       ‚à® (cmd = ".exit" ‚áí output = "Exiting..." ‚àß exitRepl())
  
  // Update command history
  ‚àß commandHistory' = commandHistory ++ ‚ü®command‚ü©

/**
 * Handle multiline input in REPL
 */
ŒîHandleMultilineInput
  ReplState
  ReplState'
  line: String
where
  // Add to current input
  currentInput' = currentInput ++ line ++ "\n"
  
  // Check if input is complete
  ‚àß if isInputComplete(currentInput')
    then processInput(currentInput') ‚àß currentInput' = ""
    else multilineMode' = true

// ============================================================================
// Server Operations
// ============================================================================

/**
 * Handle chat completion request
 */
ŒîHandleChatCompletion
  ServerState
  ServerState'
  request: JsonValue
  response: JsonValue
  streaming: ùîπ
where
  // Parse request
  let modelId = request["model"]
      messages = parseMessages(request["messages"])
      stream = request["stream"].value
      temperature = request["temperature"]
      topP = request["top_p"]
  
  // Validate model
  in (‚àÉ m : availableModels ‚Ä¢ modelId(m) = modelId)
  
  // Process request
  ‚àß let model = (the m : availableModels | modelId(m) = modelId)
        result = if stream 
                 then streamChatCompletion(model, messages)
                 else callChatCompletion(model, messages)
    in response = formatChatCompletionResponse(result, stream)
  
  // Update statistics
  ‚àß totalRequests' = totalRequests + 1
  ‚àß (error.isSome ‚áí totalErrors' = totalErrors + 1)

/**
 * Handle embeddings request
 */
ŒîHandleEmbeddings
  ServerState
  ServerState'
  request: JsonValue
  response: JsonValue
where
  // Parse request
  let modelId = request["model"]
      input = request["input"]
  
  // Validate embedding model
  in (‚àÉ m : availableModels ‚Ä¢ modelId(m) = modelId 
                              ‚àß m.data.modelType = "embedding")
  
  // Generate embeddings
  ‚àß let model = (the m : availableModels | modelId(m) = modelId)
        embeddings = generateEmbeddings(input, modelId)
    in response = formatEmbeddingsResponse(embeddings)
  
  // Update statistics
  ‚àß totalRequests' = totalRequests + 1

/**
 * Handle rerank request
 */
ŒîHandleRerank
  ServerState
  ServerState'
  request: JsonValue
  response: JsonValue
where
  // Parse request
  let modelId = request["model"]
      query = request["query"]
      documents = request["documents"]
      topN = request["top_n"]
  
  // Validate reranker model
  in (‚àÉ m : availableModels ‚Ä¢ modelId(m) = modelId 
                              ‚àß m.data.modelType = "reranker")
  
  // Rerank documents
  ‚àß let rankings = rerankDocuments(query, documents, modelId, topN)
    in response = formatRerankResponse(rankings)
  
  // Update statistics
  ‚àß totalRequests' = totalRequests + 1

// ============================================================================
// Abort Operations
// ============================================================================

/**
 * Set abort signal to interrupt operations
 */
ŒîAbortOperation
  ApplicationState
  ApplicationState'
where
  abortSignal' = true
  
  // Cancel any ongoing processing
  ‚àß (‚àÄ processing : MessageProcessingState 
     ‚Ä¢ processing.completed = false ‚áí cancelProcessing(processing))

/**
 * Clear abort signal
 */
ŒîClearAbortSignal
  ApplicationState
  ApplicationState'
where
  abortSignal' = false
