/**
 * AIChat External Integrations Formal Specification (Z++)
 * 
 * This file formalizes the contracts and specifications for external
 * service integrations including LLM provider APIs, HTTP protocols,
 * file system operations, and function calling integrations.
 */

// ============================================================================
// HTTP Protocol Specifications
// ============================================================================

/**
 * HTTP method enumeration
 */
HttpMethod ::= GET | POST | PUT | DELETE | PATCH

/**
 * HTTP status codes
 */
HttpStatus ::= OkâŸ¨200âŸ© | CreatedâŸ¨201âŸ© | BadRequestâŸ¨400âŸ© | UnauthorizedâŸ¨401âŸ© 
             | ForbiddenâŸ¨403âŸ© | NotFoundâŸ¨404âŸ© | TooManyRequestsâŸ¨429âŸ© 
             | InternalServerErrorâŸ¨500âŸ© | ServiceUnavailableâŸ¨503âŸ©

/**
 * HTTP headers
 */
[HttpHeaders]
  headers: String â‡¸ String
where
  "Content-Type" âˆˆ dom headers
  âˆ¨ "content-type" âˆˆ dom headers

/**
 * HTTP request
 */
[HttpRequest]
  method: HttpMethod
  url: String
  headers: HttpHeaders
  body: Option[String]
where
  url.value â‰  âŸ¨âŸ©
  âˆ§ (method âˆˆ {POST, PUT, PATCH} â‡’ body.isSome)

/**
 * HTTP response
 */
[HttpResponse]
  status: HttpStatus
  headers: HttpHeaders
  body: String
where
  (status = OkâŸ¨200âŸ© âˆ¨ status = CreatedâŸ¨201âŸ©) â‡’ body.value â‰  âŸ¨âŸ©

// ============================================================================
// LLM Provider API Contracts
// ============================================================================

/**
 * Generic LLM API request
 */
[LlmApiRequest]
  model: String
  messages: seq Message
  temperature: Option[Float64]
  topP: Option[Float64]
  maxTokens: Option[â„¤]
  stream: ğ”¹
  tools: Option[seq FunctionDeclaration]
where
  model.value â‰  âŸ¨âŸ©
  âˆ§ #messages > 0
  âˆ§ (âˆƒ t : temperature.value â€¢ 0.0 â‰¤ t â‰¤ 2.0)
  âˆ§ (âˆƒ p : topP.value â€¢ 0.0 â‰¤ p â‰¤ 1.0)
  âˆ§ (âˆƒ max : maxTokens.value â€¢ max > 0)

/**
 * LLM API response (non-streaming)
 */
[LlmApiResponse]
  id: String
  model: String
  choices: seq Choice
  usage: Option[Usage]
where
  id.value â‰  âŸ¨âŸ©
  âˆ§ #choices > 0

/**
 * Response choice
 */
[Choice]
  index: â„¤
  message: Message
  finishReason: FinishReason
where
  index â‰¥ 0

/**
 * Finish reason for response
 */
FinishReason ::= Stop | Length | ToolCalls | ContentFilter | ErrorâŸ¨StringâŸ©

/**
 * Token usage statistics
 */
[Usage]
  promptTokens: â„¤
  completionTokens: â„¤
  totalTokens: â„¤
where
  promptTokens â‰¥ 0
  âˆ§ completionTokens â‰¥ 0
  âˆ§ totalTokens = promptTokens + completionTokens

/**
 * Streaming chunk
 */
[StreamChunk]
  id: String
  model: String
  choices: seq StreamChoice
where
  id.value â‰  âŸ¨âŸ©
  âˆ§ #choices > 0

[StreamChoice]
  index: â„¤
  delta: MessageDelta
  finishReason: Option[FinishReason]
where
  index â‰¥ 0

[MessageDelta]
  role: Option[MessageRole]
  content: Option[String]
  toolCalls: Option[seq ToolCall]

// ============================================================================
// OpenAI API Contract
// ============================================================================

/**
 * OpenAI chat completion request
 * 
 * Conforms to OpenAI API v1 specification
 */
[OpenAIChatRequest]
  LlmApiRequest
  frequencyPenalty: Option[Float64]
  presencePenalty: Option[Float64]
  user: Option[String]
where
  (âˆƒ fp : frequencyPenalty.value â€¢ -2.0 â‰¤ fp â‰¤ 2.0)
  âˆ§ (âˆƒ pp : presencePenalty.value â€¢ -2.0 â‰¤ pp â‰¤ 2.0)

/**
 * OpenAI chat completion endpoint
 * 
 * POST https://api.openai.com/v1/chat/completions
 */
ÎOpenAIChatCompletion
  request: OpenAIChatRequest
  response: LlmApiResponse
  error: Option[String]
where
  // Request validation
  request.model.value â‰  âŸ¨âŸ©
  âˆ§ #request.messages > 0
  
  // Authentication required
  âˆ§ "Authorization" âˆˆ dom request.headers.headers
  
  // Response on success
  âˆ§ (error.isSome = false â‡’ 
     response.model = request.model
     âˆ§ #response.choices > 0)
  
  // Error handling
  âˆ§ (error.isSome â‡’ 
     error.value âˆˆ {"invalid_request_error", "authentication_error", 
                    "rate_limit_error", "server_error"})

/**
 * OpenAI embeddings request
 */
[OpenAIEmbeddingsRequest]
  model: String
  input: seq String
  dimensions: Option[â„¤]
where
  model.value â‰  âŸ¨âŸ©
  âˆ§ #input > 0
  âˆ§ (âˆƒ d : dimensions.value â€¢ d > 0)

/**
 * OpenAI embeddings response
 */
[OpenAIEmbeddingsResponse]
  data: seq EmbeddingObject
  usage: Usage
where
  #data > 0

[EmbeddingObject]
  index: â„¤
  embedding: seq Float64
where
  index â‰¥ 0
  âˆ§ #embedding > 0

/**
 * OpenAI embeddings endpoint
 * 
 * POST https://api.openai.com/v1/embeddings
 */
ÎOpenAIEmbeddings
  request: OpenAIEmbeddingsRequest
  response: OpenAIEmbeddingsResponse
where
  #response.data = #request.input
  âˆ§ (âˆ€ i : â„• | i < #response.data â€¢ response.data[i].index = i)

// ============================================================================
// Claude (Anthropic) API Contract
// ============================================================================

/**
 * Claude API uses different message format
 */
[ClaudeMessage]
  role: MessageRole
  content: seq ContentBlock
where
  role âˆˆ {User, Assistant}

ContentBlock ::= TextâŸ¨StringâŸ© | ImageâŸ¨source: ImageSourceâŸ© 
               | ToolUseâŸ¨id: String, name: String, input: JsonValueâŸ©
               | ToolResultâŸ¨toolUseId: String, content: StringâŸ©

[ImageSource]
  type: String
  mediaType: String
  data: String
where
  type = "base64"
  âˆ§ mediaType âˆˆ {"image/jpeg", "image/png", "image/gif", "image/webp"}

/**
 * Claude chat request
 */
[ClaudeChatRequest]
  model: String
  messages: seq ClaudeMessage
  maxTokens: â„¤
  system: Option[String]
  temperature: Option[Float64]
  topP: Option[Float64]
  tools: Option[seq FunctionDeclaration]
  stream: ğ”¹
where
  model.value â‰  âŸ¨âŸ©
  âˆ§ #messages > 0
  âˆ§ maxTokens > 0
  âˆ§ (âˆƒ t : temperature.value â€¢ 0.0 â‰¤ t â‰¤ 1.0)

/**
 * Claude API endpoint
 * 
 * POST https://api.anthropic.com/v1/messages
 */
ÎClaudeMessages
  request: ClaudeChatRequest
  response: LlmApiResponse
  apiVersion: String
where
  // API version required in headers
  apiVersion âˆˆ {"2023-06-01", "2024-01-01"}
  
  // Max tokens is required (not optional)
  âˆ§ request.maxTokens > 0

// ============================================================================
// Gemini (Google AI) API Contract
// ============================================================================

/**
 * Gemini uses different content structure
 */
[GeminiContent]
  role: String
  parts: seq GeminiPart
where
  role âˆˆ {"user", "model"}

GeminiPart ::= TextâŸ¨text: StringâŸ© 
             | InlineDataâŸ¨mimeType: String, data: StringâŸ©
             | FunctionCallâŸ¨name: String, args: JsonValueâŸ©
             | FunctionResponseâŸ¨name: String, response: JsonValueâŸ©

/**
 * Gemini generate content request
 */
[GeminiGenerateRequest]
  model: String
  contents: seq GeminiContent
  generationConfig: Option[GenerationConfig]
  tools: Option[seq FunctionDeclaration]
where
  model.value â‰  âŸ¨âŸ©
  âˆ§ #contents > 0

[GenerationConfig]
  temperature: Option[Float64]
  topP: Option[Float64]
  topK: Option[â„¤]
  maxOutputTokens: Option[â„¤]
where
  (âˆƒ t : temperature.value â€¢ 0.0 â‰¤ t â‰¤ 2.0)
  âˆ§ (âˆƒ k : topK.value â€¢ k > 0)

/**
 * Gemini API endpoint
 * 
 * POST https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent
 */
ÎGeminiGenerateContent
  request: GeminiGenerateRequest
  response: LlmApiResponse
  apiKey: String
where
  apiKey.value â‰  âŸ¨âŸ©

// ============================================================================
// Azure OpenAI API Contract
// ============================================================================

/**
 * Azure OpenAI extends standard OpenAI with deployment-specific endpoints
 */
[AzureOpenAIRequest]
  OpenAIChatRequest
  deployment: String
  apiVersion: String
where
  deployment.value â‰  âŸ¨âŸ©
  âˆ§ apiVersion.value â‰  âŸ¨âŸ©

/**
 * Azure OpenAI endpoint
 * 
 * POST https://{resource}.openai.azure.com/openai/deployments/{deployment}/chat/completions?api-version={version}
 */
ÎAzureOpenAIChatCompletion
  request: AzureOpenAIRequest
  response: LlmApiResponse
  resourceName: String
where
  resourceName.value â‰  âŸ¨âŸ©
  âˆ§ "api-key" âˆˆ dom request.headers.headers

// ============================================================================
// AWS Bedrock API Contract
// ============================================================================

/**
 * Bedrock uses AWS Signature V4 authentication
 */
[BedrockRequest]
  LlmApiRequest
  region: String
  accessKeyId: String
  secretAccessKey: String
  sessionToken: Option[String]
where
  region.value â‰  âŸ¨âŸ©
  âˆ§ accessKeyId.value â‰  âŸ¨âŸ©
  âˆ§ secretAccessKey.value â‰  âŸ¨âŸ©

/**
 * Bedrock invoke model endpoint
 * 
 * POST https://bedrock-runtime.{region}.amazonaws.com/model/{modelId}/invoke
 */
ÎBedrockInvokeModel
  request: BedrockRequest
  response: LlmApiResponse
  awsSignature: String
where
  // AWS Signature V4 required
  awsSignature.value â‰  âŸ¨âŸ©

// ============================================================================
// Streaming Protocol (Server-Sent Events)
// ============================================================================

/**
 * Server-Sent Event (SSE) for streaming responses
 */
[ServerSentEvent]
  event: Option[String]
  data: String
  id: Option[String]
  retry: Option[â„¤]
where
  data.value â‰  âŸ¨âŸ©

/**
 * SSE stream
 */
[SseStream]
  events: seq ServerSentEvent
  done: ğ”¹
where
  (done â‡’ 
   âˆƒ e : events â€¢ e.data = "[DONE]")

/**
 * Streaming chat completion
 */
ÎStreamChatCompletion
  request: LlmApiRequest
  stream: SseStream
where
  request.stream = true
  âˆ§ #stream.events > 0
  âˆ§ (âˆ€ e : stream.events â€¢ parseStreamChunk(e.data))

// ============================================================================
// File System Operations
// ============================================================================

/**
 * File path validation
 */
[FilePath]
  path: String
  isAbsolute: ğ”¹
  exists: ğ”¹
where
  path.value â‰  âŸ¨âŸ©
  âˆ§ Â¬containsPathTraversal(path)

/**
 * Read file operation
 */
ÎReadFile
  path: FilePath
  content: String
  error: Option[String]
where
  path.exists = true
  âˆ§ (error.isSome = false â‡’ content.value â‰  âŸ¨âŸ©)

/**
 * Write file operation
 */
Î”WriteFile
  path: FilePath
  content: String
  created: ğ”¹
  error: Option[String]
where
  content.value â‰  âŸ¨âŸ©
  âˆ§ ensureParentExists(path)
  âˆ§ (error.isSome = false â‡’ 
     path'.exists = true âˆ§ created = Â¬path.exists)

/**
 * List directory operation
 */
ÎListDirectory
  path: FilePath
  entries: seq FilePath
  error: Option[String]
where
  path.exists = true
  âˆ§ isDirectory(path)

// ============================================================================
// Document Loading
// ============================================================================

/**
 * Document loader interface
 */
[DocumentLoader]
  supportedExtensions: seq String
  mimeTypes: seq String
where
  #supportedExtensions > 0

/**
 * Load document operation
 */
ÎLoadDocument
  loader: DocumentLoader
  path: FilePath
  document: Document
  error: Option[String]
where
  // File must exist
  path.exists = true
  
  // Extension must be supported
  âˆ§ let ext = getFileExtension(path)
    in ext âˆˆ ran loader.supportedExtensions
  
  // Document loaded successfully
  âˆ§ (error.isSome = false â‡’ 
     document.path = path.path
     âˆ§ document.content.value â‰  âŸ¨âŸ©)

/**
 * Built-in document loaders
 */
TEXT_LOADER: DocumentLoader = DocumentLoaderâŸ¨
  supportedExtensions = âŸ¨"txt", "md", "markdown", "log"âŸ©,
  mimeTypes = âŸ¨"text/plain", "text/markdown"âŸ©
âŸ©

PDF_LOADER: DocumentLoader = DocumentLoaderâŸ¨
  supportedExtensions = âŸ¨"pdf"âŸ©,
  mimeTypes = âŸ¨"application/pdf"âŸ©
âŸ©

HTML_LOADER: DocumentLoader = DocumentLoaderâŸ¨
  supportedExtensions = âŸ¨"html", "htm"âŸ©,
  mimeTypes = âŸ¨"text/html"âŸ©
âŸ©

// ============================================================================
// Web Scraping Operations
// ============================================================================

/**
 * HTTP GET request for web content
 */
ÎFetchUrl
  url: String
  content: String
  statusCode: HttpStatus
  error: Option[String]
where
  url.value â‰  âŸ¨âŸ©
  âˆ§ isValidUrl(url)
  âˆ§ (statusCode = OkâŸ¨200âŸ© â‡’ content.value â‰  âŸ¨âŸ©)

/**
 * HTML to Markdown conversion
 */
ÎConvertHtmlToMarkdown
  html: String
  markdown: String
where
  html.value â‰  âŸ¨âŸ©
  âˆ§ markdown.value â‰  âŸ¨âŸ©
  âˆ§ preservesTextContent(html, markdown)

// ============================================================================
// Function Execution Integrations
// ============================================================================

/**
 * Shell command execution
 */
ÎExecuteShellCommand
  command: String
  workingDir: Option[FilePath]
  env: String â‡¸ String
  output: String
  exitCode: â„¤
  error: Option[String]
where
  command.value â‰  âŸ¨âŸ©
  âˆ§ Â¬containsMaliciousPatterns(command)
  âˆ§ (exitCode = 0 â‡’ error.isSome = false)

/**
 * MCP (Model Context Protocol) server integration
 */
[McpServer]
  name: String
  command: String
  args: seq String
  env: String â‡¸ String
where
  name.value â‰  âŸ¨âŸ©
  âˆ§ command.value â‰  âŸ¨âŸ©

/**
 * MCP tool call
 */
ÎCallMcpTool
  server: McpServer
  toolName: String
  arguments: JsonValue
  result: JsonValue
  error: Option[String]
where
  toolName.value â‰  âŸ¨âŸ©
  âˆ§ (error.isSome = false â‡’ result â‰  Null)

// ============================================================================
// Rate Limiting
// ============================================================================

/**
 * Rate limit configuration
 */
[RateLimit]
  requestsPerMinute: â„¤
  requestsPerDay: â„¤
  tokensPerMinute: â„¤
where
  requestsPerMinute > 0
  âˆ§ requestsPerDay > 0
  âˆ§ tokensPerMinute > 0

/**
 * Rate limiter state
 */
[RateLimiterState]
  limit: RateLimit
  currentMinuteRequests: â„¤
  currentDayRequests: â„¤
  currentMinuteTokens: â„¤
  windowStart: Timestamp
where
  currentMinuteRequests â‰¤ limit.requestsPerMinute
  âˆ§ currentDayRequests â‰¤ limit.requestsPerDay
  âˆ§ currentMinuteTokens â‰¤ limit.tokensPerMinute

/**
 * Check rate limit
 */
ÎCheckRateLimit
  state: RateLimiterState
  requestTokens: â„¤
  allowed: ğ”¹
where
  allowed = (state.currentMinuteRequests < state.limit.requestsPerMinute)
          âˆ§ (state.currentDayRequests < state.limit.requestsPerDay)
          âˆ§ (state.currentMinuteTokens + requestTokens â‰¤ state.limit.tokensPerMinute)

/**
 * Update rate limit after request
 */
Î”UpdateRateLimit
  RateLimiterState
  RateLimiterState'
  requestTokens: â„¤
where
  currentMinuteRequests' = currentMinuteRequests + 1
  âˆ§ currentDayRequests' = currentDayRequests + 1
  âˆ§ currentMinuteTokens' = currentMinuteTokens + requestTokens

// ============================================================================
// Error Handling & Retry Logic
// ============================================================================

/**
 * Retry configuration
 */
[RetryConfig]
  maxRetries: â„¤
  initialDelay: â„¤
  maxDelay: â„¤
  backoffMultiplier: Float64
where
  maxRetries â‰¥ 0
  âˆ§ initialDelay > 0
  âˆ§ maxDelay > initialDelay
  âˆ§ backoffMultiplier.value > 1.0

/**
 * Retry state
 */
[RetryState]
  config: RetryConfig
  attemptNumber: â„¤
  lastError: Option[String]
  nextDelay: â„¤
where
  0 â‰¤ attemptNumber â‰¤ config.maxRetries
  âˆ§ nextDelay â‰¤ config.maxDelay

/**
 * Calculate next retry delay (exponential backoff)
 */
calculateRetryDelay : RetryState â†’ â„¤
calculateRetryDelay(state) = 
  min(state.config.maxDelay,
      âŒŠstate.config.initialDelay * 
       (state.config.backoffMultiplier.value ^ state.attemptNumber)âŒ‹)

/**
 * Retry operation with exponential backoff
 */
Î”RetryOperation
  RetryState
  RetryState'
  operation: ApplicationState â†’ (ApplicationState Ã— Option[String])
  success: ğ”¹
where
  attemptNumber < config.maxRetries
  âˆ§ let (_, error) = operation(initialState)
    in (error.isSome â‡’ 
        attemptNumber' = attemptNumber + 1
        âˆ§ lastError' = error
        âˆ§ nextDelay' = calculateRetryDelay(RetryState')
        âˆ§ success = false)
       âˆ§ (error.isSome = false â‡’ success = true)

// ============================================================================
// Authentication & Security
// ============================================================================

/**
 * API key authentication
 */
[ApiKeyAuth]
  headerName: String
  headerValue: String
where
  headerName âˆˆ {"Authorization", "api-key", "x-api-key"}
  âˆ§ headerValue.value â‰  âŸ¨âŸ©

/**
 * OAuth2 authentication
 */
[OAuth2Auth]
  accessToken: String
  tokenType: String
  expiresAt: Option[Timestamp]
where
  accessToken.value â‰  âŸ¨âŸ©
  âˆ§ tokenType âˆˆ {"Bearer", "bearer"}

/**
 * AWS Signature V4 authentication
 */
[AwsSignatureV4]
  accessKeyId: String
  secretAccessKey: String
  region: String
  service: String
  signedHeaders: String
  signature: String
where
  accessKeyId.value â‰  âŸ¨âŸ©
  âˆ§ secretAccessKey.value â‰  âŸ¨âŸ©
  âˆ§ signature.value â‰  âŸ¨âŸ©

/**
 * Validate authentication
 */
ÎValidateAuth
  auth: ApiKeyAuth | OAuth2Auth | AwsSignatureV4
  valid: ğ”¹
  error: Option[String]
where
  (auth is ApiKeyAuth â‡’ 
   valid = (auth.headerValue.value â‰  âŸ¨âŸ©))
  âˆ§ (auth is OAuth2Auth â‡’ 
   valid = (auth.accessToken.value â‰  âŸ¨âŸ© 
            âˆ§ (auth.expiresAt.isSome â‡’ 
               auth.expiresAt.value.seconds > currentTime())))

// ============================================================================
// Integration Invariants
// ============================================================================

/**
 * External integration safety properties
 */
[IntegrationSafety]
  
  // All HTTP requests must have authentication
  âˆ€ req : HttpRequest to LLM provider 
    â€¢ ("Authorization" âˆˆ dom req.headers.headers
       âˆ¨ "api-key" âˆˆ dom req.headers.headers
       âˆ¨ "x-api-key" âˆˆ dom req.headers.headers)
  
  // All file paths must be validated
  âˆ§ âˆ€ path : FilePath 
    â€¢ Â¬containsPathTraversal(path)
  
  // All shell commands must be sanitized
  âˆ§ âˆ€ cmd : String executed as shell command
    â€¢ Â¬containsMaliciousPatterns(cmd)
  
  // Rate limits must be respected
  âˆ§ âˆ€ state : RateLimiterState 
    â€¢ state.currentMinuteRequests â‰¤ state.limit.requestsPerMinute
  
  // Retry logic must have bounded attempts
  âˆ§ âˆ€ state : RetryState 
    â€¢ state.attemptNumber â‰¤ state.config.maxRetries
  
  // Streaming must handle connection errors gracefully
  âˆ§ âˆ€ stream : SseStream 
    â€¢ (stream.done âˆ¨ connectionAlive(stream))

/**
 * Helper predicates for security validation
 */
containsPathTraversal : String â†’ ğ”¹
containsPathTraversal(path) = 
  contains(path, "..") âˆ¨ contains(path, "~")

containsMaliciousPatterns : String â†’ ğ”¹
containsMaliciousPatterns(cmd) = 
  contains(cmd, "rm -rf /") 
  âˆ¨ contains(cmd, "; rm ")
  âˆ¨ contains(cmd, "| rm ")
  âˆ¨ contains(cmd, "&& rm ")

isValidUrl : String â†’ ğ”¹
isValidUrl(url) = 
  startsWith(url, "http://") âˆ¨ startsWith(url, "https://")

preservesTextContent : String Ã— String â†’ ğ”¹
preservesTextContent(html, markdown) = 
  let htmlText = extractText(html)
      mdText = extractText(markdown)
  in similarity(htmlText, mdText) > 0.9
