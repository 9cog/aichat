/**
 * AIChat Data Model Formal Specification (Z++)
 * 
 * This file formalizes the data layer of the AIChat system, including
 * entity definitions, state invariants, and relationships between data models.
 * 
 * The specification focuses on backend core logic: configuration, models,
 * messages, sessions, roles, agents, RAG systems, and functions.
 */

// ============================================================================
// Basic Types and Constants
// ============================================================================

/**
 * Basic string type representing UTF-8 encoded text
 */
[String]
  value: seq ‚Ñ§
where
  ‚àÄ c : value ‚Ä¢ 0 ‚â§ c ‚â§ 1114111  // Valid Unicode code points

/**
 * Optional value type
 */
[Option[T]]
  isSome: ùîπ
  value: T
where
  isSome ‚áí value ‚â† ‚ä•

/**
 * Floating point number (representing f64 in Rust)
 */
[Float64]
  value: ‚Ñù
where
  -‚àû < value < ‚àû

/**
 * Unsigned 32-bit integer
 */
[UInt32]
  value: ‚Ñ§
where
  0 ‚â§ value ‚â§ 4294967295

/**
 * Unix timestamp in seconds
 */
[Timestamp]
  seconds: ‚Ñ§
where
  seconds ‚â• 0

/**
 * JSON value representation
 */
JsonValue ::= Null | Boolean‚ü®ùîπ‚ü© | Number‚ü®‚Ñù‚ü© | String‚ü®String‚ü© 
            | Array‚ü®seq JsonValue‚ü© | Object‚ü®String ‚á∏ JsonValue‚ü©

// ============================================================================
// Enumeration Types
// ============================================================================

/**
 * Working mode of the application
 */
WorkingMode ::= CMD | REPL | Serve

/**
 * Message role in conversation
 */
MessageRole ::= System | User | Assistant | Tool

/**
 * Model type classification
 */
ModelType ::= Chat | Embedding | Reranker

/**
 * Client type for LLM providers
 */
ClientType ::= OpenAI | OpenAICompatible | Gemini | Claude | Cohere 
             | AzureOpenAI | VertexAI | Bedrock

// ============================================================================
// Model Entity
// ============================================================================

/**
 * ModelData represents the metadata and capabilities of an LLM model.
 * 
 * Invariants:
 * - Model must have a name
 * - Token limits must be positive if specified
 * - Prices must be non-negative if specified
 * - Input tokens cannot exceed model's max input tokens
 */
[ModelData]
  name: String
  realName: Option[String]
  modelType: String
  maxInputTokens: Option[‚Ñ§]
  maxOutputTokens: Option[‚Ñ§]
  inputPrice: Option[Float64]
  outputPrice: Option[Float64]
  supportsVision: ùîπ
  supportsFunctionCalling: ùîπ
where
  name.value ‚â† ‚ü®‚ü©  // Non-empty name
  ‚àß (‚àÉ max : maxInputTokens.value ‚Ä¢ max > 0)
  ‚àß (‚àÉ max : maxOutputTokens.value ‚Ä¢ max > 0)
  ‚àß (‚àÉ price : inputPrice.value ‚Ä¢ price ‚â• 0.0)
  ‚àß (‚àÉ price : outputPrice.value ‚Ä¢ price ‚â• 0.0)

/**
 * Model associates a client name with model data.
 */
[Model]
  clientName: String
  data: ModelData
where
  clientName.value ‚â† ‚ü®‚ü©  // Non-empty client name

/**
 * Model identifier composition
 */
modelId : Model ‚Üí String
modelId(m) = if m.data.name.value = ‚ü®‚ü© 
             then m.clientName 
             else m.clientName ++ ":" ++ m.data.name

// ============================================================================
// Message Entity
// ============================================================================

/**
 * Message content can be text, image, or tool calls
 */
MessageContentPart ::= Text‚ü®String‚ü© 
                     | ImageUrl‚ü®url: String, detail: Option[String]‚ü©

[MessageContent]
  parts: seq MessageContentPart
where
  #parts > 0  // At least one content part

/**
 * Tool call represents a function invocation request from the LLM
 */
[ToolCall]
  id: String
  name: String
  arguments: JsonValue
where
  id.value ‚â† ‚ü®‚ü©
  ‚àß name.value ‚â† ‚ü®‚ü©
  ‚àß arguments ‚â† Null

/**
 * Message in a conversation
 * 
 * Invariants:
 * - Tool role messages must have a corresponding tool call ID
 * - Assistant messages with tool calls must have function calling content
 */
[Message]
  role: MessageRole
  content: MessageContent
  toolCalls: seq ToolCall
  toolCallId: Option[String]
where
  (role = Tool ‚áí toolCallId.isSome)
  ‚àß (#toolCalls > 0 ‚áí role = Assistant)

/**
 * Token estimation for a message
 */
estimateMessageTokens : Message ‚Üí ‚Ñ§
estimateMessageTokens(m) = 
  let textLength = Œ£_{p ‚àà m.content.parts} contentLength(p)
  in ‚åàtextLength / 4‚åâ + 5  // Rough estimate: 4 chars per token + overhead

// ============================================================================
// Configuration Entity
// ============================================================================

/**
 * Client configuration for an LLM provider
 * 
 * Each client has a unique name and type, with provider-specific settings.
 */
[ClientConfig]
  name: String
  clientType: ClientType
  apiKey: Option[String]
  apiBase: Option[String]
  models: seq ModelData
  extraConfig: String ‚á∏ JsonValue
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #models ‚àß j < #models 
     ‚Ä¢ models[i].name ‚â† models[j].name)  // Unique model names

/**
 * Global application configuration
 * 
 * Invariants:
 * - Must have at least one client configured
 * - Model ID must reference a valid model from a configured client
 * - Temperature must be in valid range [0.0, 2.0]
 * - Top-p must be in valid range [0.0, 1.0]
 * - RAG top-k must be positive
 * - Compress threshold must be positive
 */
[Config]
  modelId: String
  temperature: Option[Float64]
  topP: Option[Float64]
  
  dryRun: ùîπ
  stream: ùîπ
  save: ùîπ
  keybindings: String
  editor: Option[String]
  wrap: Option[String]
  wrapCode: ùîπ
  
  functionCalling: ùîπ
  mappingTools: String ‚á∏ String
  useTools: Option[String]
  
  replPrelude: Option[String]
  cmdPrelude: Option[String]
  agentPrelude: Option[String]
  
  saveSession: Option[ùîπ]
  compressThreshold: ‚Ñ§
  summarizePrompt: Option[String]
  summaryPrompt: Option[String]
  
  ragEmbeddingModel: Option[String]
  ragRerankerModel: Option[String]
  ragTopK: ‚Ñ§
  ragChunkSize: Option[‚Ñ§]
  ragChunkOverlap: Option[‚Ñ§]
  ragTemplate: Option[String]
  
  documentLoaders: String ‚á∏ String
  
  highlight: ùîπ
  theme: Option[String]
  leftPrompt: Option[String]
  rightPrompt: Option[String]
  
  serveAddr: Option[String]
  userAgent: Option[String]
  saveShellHistory: ùîπ
  syncModelsUrl: Option[String]
  
  clients: seq ClientConfig
  
  workingMode: WorkingMode
  infoFlag: ùîπ
where
  #clients > 0  // At least one client
  ‚àß modelId.value ‚â† ‚ü®‚ü©
  ‚àß (‚àÉ t : temperature.value ‚Ä¢ 0.0 ‚â§ t ‚â§ 2.0)
  ‚àß (‚àÉ p : topP.value ‚Ä¢ 0.0 ‚â§ p ‚â§ 1.0)
  ‚àß compressThreshold > 0
  ‚àß ragTopK > 0
  ‚àß (‚àÉ size : ragChunkSize.value ‚Ä¢ size > 0)
  ‚àß (‚àÉ overlap : ragChunkOverlap.value ‚Ä¢ overlap ‚â• 0)
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #clients ‚àß j < #clients 
     ‚Ä¢ clients[i].name ‚â† clients[j].name)  // Unique client names

// ============================================================================
// Role Entity
// ============================================================================

/**
 * Role defines LLM behavior through a prompt template
 * 
 * Invariants:
 * - Role must have a non-empty name
 * - If model override is specified, it must be a valid model ID
 */
[Role]
  name: String
  prompt: String
  modelId: Option[String]
  temperature: Option[Float64]
  topP: Option[Float64]
  useTools: Option[String]
  model: Model
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß (‚àÉ t : temperature.value ‚Ä¢ 0.0 ‚â§ t ‚â§ 2.0)
  ‚àß (‚àÉ p : topP.value ‚Ä¢ 0.0 ‚â§ p ‚â§ 1.0)

/**
 * Built-in system roles
 */
SHELL_ROLE: String = "%shell%"
EXPLAIN_SHELL_ROLE: String = "%explain-shell%"
CODE_ROLE: String = "%code%"
CREATE_TITLE_ROLE: String = "%create-title%"
TEMP_ROLE_NAME: String = "%%"

// ============================================================================
// Session Entity
// ============================================================================

/**
 * Session maintains conversation context and message history
 * 
 * Invariants:
 * - Session must have a non-empty name
 * - Messages must alternate between user and assistant (after initial system message)
 * - Compressed messages are older than current messages
 * - Token count must match actual message tokens
 * - If save_session is enabled, session should be persisted
 */
[Session]
  name: String
  modelId: String
  temperature: Option[Float64]
  topP: Option[Float64]
  useTools: Option[String]
  saveSession: Option[ùîπ]
  compressThreshold: Option[‚Ñ§]
  
  roleName: Option[String]
  agentVariables: String ‚á∏ String
  agentInstructions: String
  
  compressedMessages: seq Message
  messages: seq Message
  dataUrls: String ‚á∏ String
  
  model: Model
  rolePrompt: String
  path: Option[String]
  dirty: ùîπ
  saveSessionThisTime: ùîπ
  compressing: ùîπ
  tokens: ‚Ñ§
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß modelId.value ‚â† ‚ü®‚ü©
  ‚àß tokens = Œ£_{m ‚àà compressedMessages ++ messages} estimateMessageTokens(m)
  ‚àß (‚àÉ threshold : compressThreshold.value 
     ‚Ä¢ threshold > 0 ‚àß (tokens > threshold ‚áí compressing))
  ‚àß (dirty ‚áí #messages > 0)  // Dirty implies messages exist

/**
 * Session is empty if no messages
 */
sessionIsEmpty : Session ‚Üí ùîπ
sessionIsEmpty(s) = (#s.messages = 0) ‚àß (#s.compressedMessages = 0)

/**
 * Count user messages in session
 */
userMessageCount : Session ‚Üí ‚Ñ§
userMessageCount(s) = #{m ‚àà s.messages | m.role = User}

// ============================================================================
// Agent Entity
// ============================================================================

/**
 * Agent variable definition
 */
[AgentVariable]
  name: String
  description: Option[String]
  default: Option[String]
where
  name.value ‚â† ‚ü®‚ü©

/**
 * Agent definition from configuration
 */
[AgentDefinition]
  name: String
  description: String
  version: String
  instructions: String
  variables: seq AgentVariable
  documents: seq String
  conversationStarters: seq String
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß version.value ‚â† ‚ü®‚ü©
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #variables ‚àß j < #variables 
     ‚Ä¢ variables[i].name ‚â† variables[j].name)  // Unique variable names

/**
 * Agent configuration
 */
[AgentConfig]
  modelId: Option[String]
  temperature: Option[Float64]
  topP: Option[Float64]
  useTools: Option[String]
where
  (‚àÉ t : temperature.value ‚Ä¢ 0.0 ‚â§ t ‚â§ 2.0)
  ‚àß (‚àÉ p : topP.value ‚Ä¢ 0.0 ‚â§ p ‚â§ 1.0)

/**
 * Agent combines instructions, tools, and documents (RAG)
 * 
 * Invariants:
 * - Agent must have a unique name
 * - Shared variables apply to all sessions
 * - Session variables override shared variables when present
 * - RAG is optional but must be valid if present
 */
[Agent]
  name: String
  config: AgentConfig
  definition: AgentDefinition
  sharedVariables: String ‚á∏ String
  sessionVariables: Option[String ‚á∏ String]
  sharedDynamicInstructions: Option[String]
  sessionDynamicInstructions: Option[String]
  model: Model
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß name = definition.name
  ‚àß (‚àÄ v : definition.variables 
     ‚Ä¢ (v.name ‚àà dom sharedVariables) ‚à® v.default.isSome)

/**
 * Effective agent variables (session overrides shared)
 */
effectiveVariables : Agent ‚Üí (String ‚á∏ String)
effectiveVariables(a) = 
  if a.sessionVariables.isSome 
  then a.sharedVariables ‚äï a.sessionVariables.value
  else a.sharedVariables

// ============================================================================
// Function Calling Entity
// ============================================================================

/**
 * Function parameter definition
 */
[FunctionParameter]
  name: String
  type: String
  description: String
  required: ùîπ
  enum: Option[seq String]
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß type.value ‚â† ‚ü®‚ü©

/**
 * Function declaration for LLM function calling
 */
[FunctionDeclaration]
  name: String
  description: String
  parameters: seq FunctionParameter
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß description.value ‚â† ‚ü®‚ü©
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #parameters ‚àß j < #parameters 
     ‚Ä¢ parameters[i].name ‚â† parameters[j].name)

/**
 * Tool result after function execution
 */
[ToolResult]
  call: ToolCall
  output: JsonValue

/**
 * Functions collection
 */
[Functions]
  declarations: seq FunctionDeclaration
where
  (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #declarations ‚àß j < #declarations 
   ‚Ä¢ declarations[i].name ‚â† declarations[j].name)  // Unique function names

/**
 * Find function by name
 */
findFunction : Functions √ó String ‚Üí Option[FunctionDeclaration]
findFunction(fs, name) = 
  if (‚àÉ f : fs.declarations ‚Ä¢ f.name = name)
  then Some(the f : fs.declarations | f.name = name)
  else None

// ============================================================================
// RAG Entity
// ============================================================================

/**
 * Document chunk for vector search
 */
[Chunk]
  id: String
  text: String
  embedding: seq Float64
  metadata: String ‚á∏ JsonValue
where
  id.value ‚â† ‚ü®‚ü©
  ‚àß text.value ‚â† ‚ü®‚ü©
  ‚àß #embedding > 0

/**
 * Document loaded into RAG
 */
[Document]
  path: String
  content: String
  chunks: seq Chunk
  loader: String
where
  path.value ‚â† ‚ü®‚ü©
  ‚àß #chunks > 0
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #chunks ‚àß j < #chunks 
     ‚Ä¢ chunks[i].id ‚â† chunks[j].id)  // Unique chunk IDs

/**
 * RAG (Retrieval-Augmented Generation) system
 * 
 * Invariants:
 * - Must have a unique name
 * - Must have at least one document
 * - Embedding dimension must be consistent across all chunks
 * - Top-k must be positive and not exceed total chunks
 */
[Rag]
  name: String
  documents: seq Document
  embeddingModel: String
  rerankerModel: Option[String]
  topK: ‚Ñ§
  chunkSize: ‚Ñ§
  chunkOverlap: ‚Ñ§
  template: String
  path: String
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß #documents > 0
  ‚àß topK > 0
  ‚àß chunkSize > 0
  ‚àß chunkOverlap ‚â• 0
  ‚àß chunkOverlap < chunkSize
  ‚àß let totalChunks = Œ£_{d ‚àà documents} #d.chunks
    in topK ‚â§ totalChunks
  ‚àß let embeddingDim = if (#documents > 0 ‚àß #(documents[0].chunks) > 0)
                        then #(documents[0].chunks[0].embedding)
                        else 0
    in (‚àÄ d : documents, c : d.chunks ‚Ä¢ #c.embedding = embeddingDim)

/**
 * Query result from RAG retrieval
 */
[RagQueryResult]
  query: String
  retrievedChunks: seq Chunk
  scores: seq Float64
where
  #retrievedChunks = #scores
  ‚àß (‚àÄ i : ‚Ñï | i < #scores ‚Ä¢ scores[i] ‚â• 0.0)

// ============================================================================
// Macro Entity
// ============================================================================

/**
 * Macro variable definition
 */
[MacroVariable]
  name: String
  description: String
  default: Option[String]
where
  name.value ‚â† ‚ü®‚ü©

/**
 * Macro for automating REPL command sequences
 */
[Macro]
  name: String
  description: String
  variables: seq MacroVariable
  commands: seq String
where
  name.value ‚â† ‚ü®‚ü©
  ‚àß #commands > 0
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #variables ‚àß j < #variables 
     ‚Ä¢ variables[i].name ‚â† variables[j].name)

// ============================================================================
// Input Entity
// ============================================================================

/**
 * Input source type
 */
InputSource ::= Stdin | File‚ü®path: String‚ü© | Url‚ü®url: String‚ü© 
              | Command‚ü®cmd: String‚ü©

/**
 * Input data with metadata
 */
[InputData]
  source: InputSource
  content: String
  mimeType: Option[String]
  isImage: ùîπ
where
  content.value ‚â† ‚ü®‚ü©
  ‚àß (isImage ‚áí mimeType.isSome)

/**
 * Input collection for a query
 */
[Input]
  text: Option[String]
  data: seq InputData
  useTools: Option[String]
  
/**
 * Combined input is valid if it has text or data
 */
inputIsValid : Input ‚Üí ùîπ
inputIsValid(i) = i.text.isSome ‚à® #i.data > 0

// ============================================================================
// Data Integrity Invariants
// ============================================================================

/**
 * Global data integrity constraints
 */
[DataIntegrity]
  config: Config
  models: seq Model
  sessions: seq Session
  roles: seq Role
  agents: seq Agent
  rags: seq Rag
  functions: Functions
where
  // All models referenced in config must exist
  (‚àÉ m : models ‚Ä¢ modelId(m) = config.modelId)
  
  // All session models must be valid
  ‚àß (‚àÄ s : sessions ‚Ä¢ ‚àÉ m : models ‚Ä¢ modelId(m) = s.modelId)
  
  // All role model IDs (if specified) must be valid
  ‚àß (‚àÄ r : roles, mid : r.modelId.value 
     ‚Ä¢ ‚àÉ m : models ‚Ä¢ modelId(m) = mid)
  
  // All agent model IDs (if specified) must be valid
  ‚àß (‚àÄ a : agents, mid : a.config.modelId.value 
     ‚Ä¢ ‚àÉ m : models ‚Ä¢ modelId(m) = mid)
  
  // Session role names must reference valid roles
  ‚àß (‚àÄ s : sessions, rname : s.roleName.value 
     ‚Ä¢ ‚àÉ r : roles ‚Ä¢ r.name = rname)
  
  // Unique session names
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #sessions ‚àß j < #sessions 
     ‚Ä¢ sessions[i].name ‚â† sessions[j].name)
  
  // Unique role names
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #roles ‚àß j < #roles 
     ‚Ä¢ roles[i].name ‚â† roles[j].name)
  
  // Unique agent names
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #agents ‚àß j < #agents 
     ‚Ä¢ agents[i].name ‚â† agents[j].name)
  
  // Unique RAG names
  ‚àß (‚àÄ i, j : ‚Ñï | i ‚â† j ‚àß i < #rags ‚àß j < #rags 
     ‚Ä¢ rags[i].name ‚â† rags[j].name)
