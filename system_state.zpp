/**
 * AIChat System State Formal Specification (Z++)
 * 
 * This file formalizes the overall system state of AIChat, including
 * runtime state, session management, and global application state.
 */

// ============================================================================
// System State
// ============================================================================

/**
 * ApplicationState represents the complete runtime state of AIChat
 * 
 * This is the top-level state schema that encapsulates all application state
 * including configuration, active sessions, loaded resources, and runtime flags.
 * 
 * Invariants:
 * - Exactly one configuration must be active
 * - At most one session can be active at a time (for REPL/CMD modes)
 * - Active session must be in the sessions collection
 * - Active role must be in the roles collection
 * - Active agent must be in the agents collection
 * - Current model must be valid and from configured clients
 */
[ApplicationState]
  // Core configuration
  config: Config
  
  // Model management
  currentModel: Model
  availableModels: seq Model
  
  // Session management
  sessions: seq Session
  activeSession: Option[Session]
  
  // Role management
  roles: seq Role
  activeRole: Option[Role]
  
  // Agent management
  agents: seq Agent
  activeAgent: Option[Agent]
  
  // RAG management
  rags: seq Rag
  activeRag: Option[Rag]
  
  // Function management
  functions: Functions
  
  // Runtime state
  workingMode: WorkingMode
  abortSignal: ð”¹
  dryRunMode: ð”¹
  
  // Data integrity
  integrity: DataIntegrity
where
  // Configuration consistency
  config = integrity.config
  âˆ§ availableModels = integrity.models
  âˆ§ sessions = integrity.sessions
  âˆ§ roles = integrity.roles
  âˆ§ agents = integrity.agents
  âˆ§ rags = integrity.rags
  âˆ§ functions = integrity.functions
  
  // Current model must be in available models
  âˆ§ currentModel âˆˆ ran availableModels
  
  // Active session must be in sessions collection (if present)
  âˆ§ (âˆƒ s : activeSession.value â€¢ s âˆˆ ran sessions)
  
  // Active role must be in roles collection (if present)
  âˆ§ (âˆƒ r : activeRole.value â€¢ r âˆˆ ran roles)
  
  // Active agent must be in agents collection (if present)
  âˆ§ (âˆƒ a : activeAgent.value â€¢ a âˆˆ ran agents)
  
  // Active RAG must be in rags collection (if present)
  âˆ§ (âˆƒ rag : activeRag.value â€¢ rag âˆˆ ran rags)
  
  // Working mode matches config
  âˆ§ workingMode = config.workingMode
  
  // Dry run mode matches config
  âˆ§ dryRunMode = config.dryRun
  
  // Single active context constraint
  âˆ§ Â¬(activeSession.isSome âˆ§ activeAgent.isSome)  // Session XOR Agent

/**
 * Initial application state after startup
 */
[InitialState]
  ApplicationState
where
  #sessions = 0
  âˆ§ activeSession.isSome = false
  âˆ§ activeRole.isSome = false
  âˆ§ activeAgent.isSome = false
  âˆ§ activeRag.isSome = false
  âˆ§ abortSignal = false
  âˆ§ #availableModels > 0
  âˆ§ currentModel = head availableModels

// ============================================================================
// REPL State
// ============================================================================

/**
 * REPL-specific state for interactive mode
 * 
 * Manages the state of the Read-Eval-Print Loop including command history,
 * current input buffer, and REPL-specific flags.
 */
[ReplState]
  ApplicationState
  
  // REPL-specific state
  commandHistory: seq String
  currentInput: String
  multilineMode: ð”¹
  lastReply: Option[String]
  
  // Display state
  leftPrompt: String
  rightPrompt: String
  
  // Statistics
  messagesCount: â„¤
  tokensCount: â„¤
  consumePercent: Float64
where
  workingMode = REPL
  
  // Token statistics match active session (if exists)
  âˆ§ (âˆƒ s : activeSession.value 
     â€¢ tokensCount = s.tokens
       âˆ§ messagesCount = #s.messages
       âˆ§ (âˆƒ maxTokens : s.model.data.maxInputTokens.value
          â€¢ consumePercent.value = (tokensCount / maxTokens) * 100.0))
  
  // No active session means zero statistics
  âˆ§ (Â¬activeSession.isSome â‡’ messagesCount = 0 âˆ§ tokensCount = 0)

// ============================================================================
// CMD State
// ============================================================================

/**
 * CMD-specific state for command-line mode
 * 
 * Represents state for one-shot command execution.
 */
[CmdState]
  ApplicationState
  
  // Command input
  input: Input
  
  // Output configuration
  streamOutput: ð”¹
  saveOutput: ð”¹
  
  // Execution flags
  executeShellCommand: ð”¹
  explainShellCommand: ð”¹
  generateCode: ð”¹
where
  workingMode = CMD
  
  // CMD mode requires valid input
  âˆ§ inputIsValid(input)
  
  // No active session in CMD mode (uses temporary session)
  âˆ§ (activeSession.isSome â‡’ activeSession.value.name = TEMP_SESSION_NAME)
  
  // Stream output matches config
  âˆ§ streamOutput = config.stream

// ============================================================================
// Server State
// ============================================================================

/**
 * Connection state for a single client
 */
[ClientConnection]
  id: String
  ipAddress: String
  connectedAt: Timestamp
  requestCount: â„¤
where
  id.value â‰  âŸ¨âŸ©
  âˆ§ requestCount â‰¥ 0

/**
 * Active request being processed
 */
[ActiveRequest]
  connectionId: String
  requestId: String
  endpoint: String
  method: String
  startedAt: Timestamp
  model: Option[String]
  streaming: ð”¹
where
  connectionId.value â‰  âŸ¨âŸ©
  âˆ§ requestId.value â‰  âŸ¨âŸ©
  âˆ§ endpoint.value â‰  âŸ¨âŸ©

/**
 * Server-specific state for HTTP server mode
 * 
 * Manages concurrent client connections and request processing.
 */
[ServerState]
  ApplicationState
  
  // Server configuration
  listenAddress: String
  listenPort: â„¤
  
  // Connection management
  activeConnections: seq ClientConnection
  activeRequests: seq ActiveRequest
  
  // Server statistics
  totalRequests: â„¤
  totalErrors: â„¤
  uptime: â„¤
  
  // Server control
  shutdownRequested: ð”¹
where
  workingMode = Serve
  
  // Valid port range
  âˆ§ 1 â‰¤ listenPort â‰¤ 65535
  
  // Statistics are non-negative
  âˆ§ totalRequests â‰¥ 0
  âˆ§ totalErrors â‰¥ 0
  âˆ§ uptime â‰¥ 0
  
  // All active requests belong to active connections
  âˆ§ (âˆ€ req : activeRequests 
     â€¢ âˆƒ conn : activeConnections â€¢ conn.id = req.connectionId)
  
  // Request count matches requests processed
  âˆ§ (âˆ€ conn : activeConnections 
     â€¢ conn.requestCount = #{req : activeRequests | req.connectionId = conn.id}
       + #{completed requests from this connection})

// ============================================================================
// State Flags and Assertions
// ============================================================================

/**
 * State flags using bitflags pattern
 */
[StateFlags]
  flags: UInt32
where
  // Define flag positions
  let INTERACTIVE = 1
  let RAG_ACTIVE = 2
  let AGENT_ACTIVE = 4
  let FUNCTION_CALLING = 8
  let SESSION_ACTIVE = 16
  let ROLE_ACTIVE = 32
  let STREAM_MODE = 64
  let DRY_RUN = 128
  in true  // Flags are just bit positions

/**
 * Compute current state flags
 */
stateFlags : ApplicationState â†’ StateFlags
stateFlags(state) = 
  let flags = 0
      flags = if state.workingMode = REPL then flags | 1 else flags
      flags = if state.activeRag.isSome then flags | 2 else flags
      flags = if state.activeAgent.isSome then flags | 4 else flags
      flags = if state.config.functionCalling then flags | 8 else flags
      flags = if state.activeSession.isSome then flags | 16 else flags
      flags = if state.activeRole.isSome then flags | 32 else flags
      flags = if state.config.stream then flags | 64 else flags
      flags = if state.dryRunMode then flags | 128 else flags
  in StateFlagsâŸ¨flagsâŸ©

/**
 * Assert state consistency
 */
AssertState ::= Valid | InvalidConfig | InvalidSession | InvalidModel 
              | InvalidRole | InvalidAgent | InvalidRag

/**
 * Validate application state
 */
validateState : ApplicationState â†’ AssertState
validateState(state) =
  if Â¬(state.currentModel âˆˆ ran state.availableModels)
  then InvalidModel
  else if state.activeSession.isSome 
          âˆ§ Â¬(state.activeSession.value âˆˆ ran state.sessions)
  then InvalidSession
  else if state.activeRole.isSome 
          âˆ§ Â¬(state.activeRole.value âˆˆ ran state.roles)
  then InvalidRole
  else if state.activeAgent.isSome 
          âˆ§ Â¬(state.activeAgent.value âˆˆ ran state.agents)
  then InvalidAgent
  else if state.activeRag.isSome 
          âˆ§ Â¬(state.activeRag.value âˆˆ ran state.rags)
  then InvalidRag
  else Valid

// ============================================================================
// Message Processing State
// ============================================================================

/**
 * State during message processing pipeline
 */
[MessageProcessingState]
  ApplicationState
  
  // Input stage
  rawInput: Input
  processedInput: seq Message
  
  // Context building stage
  roleContext: seq Message
  sessionContext: seq Message
  ragContext: Option[seq String]
  agentContext: Option[seq Message]
  
  // Message construction stage
  finalMessages: seq Message
  totalTokens: â„¤
  needsCompression: ð”¹
  
  // Request stage
  requestSent: ð”¹
  streaming: ð”¹
  
  // Response stage
  partialResponse: Option[String]
  fullResponse: Option[String]
  toolCalls: seq ToolCall
  toolResults: seq ToolResult
  
  // Completion stage
  completed: ð”¹
  error: Option[String]
where
  // Valid input
  inputIsValid(rawInput)
  
  // Processed input corresponds to raw input
  âˆ§ #processedInput > 0
  
  // Final messages include all context
  âˆ§ finalMessages = roleContext ++ sessionContext ++ processedInput ++ agentContext.value
  
  // Token calculation
  âˆ§ totalTokens = Î£_{m âˆˆ finalMessages} estimateMessageTokens(m)
  
  // Compression needed if exceeds threshold
  âˆ§ (âˆƒ s : activeSession.value, threshold : s.compressThreshold.value
     â€¢ needsCompression = (totalTokens > threshold))
  
  // Streaming matches config
  âˆ§ (requestSent â‡’ streaming = config.stream)
  
  // Response state consistency
  âˆ§ (completed â‡’ (fullResponse.isSome âˆ¨ error.isSome))
  âˆ§ (streaming âˆ§ Â¬completed â‡’ partialResponse.isSome)
  
  // Tool calling state
  âˆ§ (#toolCalls > 0 â‡’ #toolResults â‰¤ #toolCalls)
  âˆ§ (âˆ€ result : toolResults â€¢ result.call âˆˆ ran toolCalls)

// ============================================================================
// Session Lifecycle State
// ============================================================================

/**
 * Session lifecycle stages
 */
SessionLifecycle ::= Created | Loading | Active | Saving | Compressing | Closed

/**
 * Session state during its lifecycle
 */
[SessionState]
  session: Session
  lifecycle: SessionLifecycle
  lastActivity: Timestamp
  autoSave: ð”¹
where
  (lifecycle = Created â‡’ sessionIsEmpty(session))
  âˆ§ (lifecycle = Active â‡’ Â¬sessionIsEmpty(session))
  âˆ§ (lifecycle = Compressing â‡’ session.compressing)
  âˆ§ (autoSave â‡’ session.saveSession.value = true)

/**
 * State transition for session lifecycle
 */
Î”SessionLifecycle
  SessionState
  SessionState'
  action: String
where
  (action = "create" 
   âˆ§ lifecycle = Created âˆ§ lifecycle' = Active
   âˆ§ session' = session)
  
  âˆ¨ (action = "load" 
     âˆ§ lifecycle = Loading âˆ§ lifecycle' = Active
     âˆ§ session'.path.isSome)
  
  âˆ¨ (action = "save" 
     âˆ§ lifecycle = Active âˆ§ lifecycle' = Saving
     âˆ§ session'.dirty = false)
  
  âˆ¨ (action = "compress" 
     âˆ§ lifecycle = Active âˆ§ lifecycle' = Compressing
     âˆ§ session'.tokens > session'.compressThreshold.value)
  
  âˆ¨ (action = "close" 
     âˆ§ lifecycle' = Closed)

// ============================================================================
// Global State Invariants
// ============================================================================

/**
 * Global invariants that must hold for all valid application states
 */
[GlobalInvariants]
  ApplicationState
where
  // Configuration is valid
  validateState(this) = Valid
  
  // No duplicate names
  âˆ§ (âˆ€ i, j : â„• | i â‰  j âˆ§ i < #sessions âˆ§ j < #sessions 
     â€¢ sessions[i].name â‰  sessions[j].name)
  âˆ§ (âˆ€ i, j : â„• | i â‰  j âˆ§ i < #roles âˆ§ j < #roles 
     â€¢ roles[i].name â‰  roles[j].name)
  âˆ§ (âˆ€ i, j : â„• | i â‰  j âˆ§ i < #agents âˆ§ j < #agents 
     â€¢ agents[i].name â‰  agents[j].name)
  âˆ§ (âˆ€ i, j : â„• | i â‰  j âˆ§ i < #rags âˆ§ j < #rags 
     â€¢ rags[i].name â‰  rags[j].name)
  
  // Resource limits
  âˆ§ #sessions â‰¤ 1000
  âˆ§ #roles â‰¤ 100
  âˆ§ #agents â‰¤ 100
  âˆ§ #rags â‰¤ 50
  
  // Active session token limits
  âˆ§ (âˆƒ s : activeSession.value, max : s.model.data.maxInputTokens.value
     â€¢ s.tokens â‰¤ max * 2)  // Allow 2x for compression buffer
  
  // Abort signal can interrupt any operation
  âˆ§ (abortSignal â‡’ 
     (âˆ€ processing : MessageProcessingState â€¢ Â¬processing.completed))

/**
 * State safety property: system never enters invalid state
 */
StateSafety: 
  âˆ€ state : ApplicationState â€¢ validateState(state) = Valid
  â‡’ âˆ€ state' : ApplicationState after any operation 
    â€¢ validateState(state') = Valid
